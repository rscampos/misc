/*
 * Simple example using 'stack overflow' "without" canary.
 * This driver has a vulnerability in function 'copy_from_user' which copy
 * 'size' bytes from a 'user buffer' to a 'kernel buffer'. After some bytes, 
 * we just overwrite the 'ret' address, hijacking the flow to the shellcode
 * present in 'user-space'.
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/miscdevice.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/string.h>

#define BUF_LEN 13
static const char device_name[]       = "vulndrive";
static const char euid[]              = "0123456789AB";

ssize_t device_read(struct file *filp,
		    char *bufStoreData, size_t bufCount, loff_t *curOffset)
{
	return simple_read_from_buffer(bufStoreData, bufCount, curOffset,
				       euid, strlen(euid));
}

ssize_t device_write(struct file *filp,
		     const char *bufSourceData, size_t bufCount,
		     loff_t *curOffset)
{
	int ret;
	char data[BUF_LEN];
	
	memset(data, '\0', BUF_LEN);

	ret = copy_from_user(data, bufSourceData, bufCount);

	data[BUF_LEN-1] = '\0';

	if (!strcmp(data, euid) == 0)
		return -EINVAL;

	return ret;
}

const struct file_operations fops = {
	.write		= device_write,
	.read		= device_read
};

struct miscdevice miscdev = {
	.minor		= MISC_DYNAMIC_MINOR,
	.name		= device_name,
	.fops		= &fops,
	.mode		= 0777
};

static int driver_entry(void)
{
	return misc_register(&miscdev);
}

static int driver_exit(void)
{
	misc_deregister(&miscdev);
}

module_init(driver_entry);
module_exit(driver_exit);
MODULE_LICENSE("GPL");
