#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/miscdevice.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/string.h>

#define BUF_LEN 13
static const char device_name[]       = "vulndrive";
static const char euid[]              = "4f92b3aee379";

ssize_t device_read(struct file *filp,
		    char *bufStoreData, size_t bufCount, loff_t *curOffset)
{
	return simple_read_from_buffer(bufStoreData, bufCount, curOffset,
				       euid, strlen(euid));
}

ssize_t device_write(struct file *filp,
		     const char *bufSourceData, size_t bufCount,
		     loff_t *curOffset)
{
	int ret, i;
	char data[BUF_LEN];
	
	memset(data, '\0', BUF_LEN);

	pr_info("----------------------------------------\n");
	pr_info("To:0x%x\n", data);
	pr_info("From:0x%x\n", bufSourceData);
	pr_info("Count:%d\n", bufCount);
	pr_info("strlen(bufSourceData):%d\n", strlen(bufSourceData));
	pr_info("Raw bytes: ");
	pr_info("|idx|before|after|");

	for(i=0; i< strlen(bufSourceData)+1; i++)
		if(i != bufCount)
			pr_info("|%d | 0x%x | 0x%x |", i, (unsigned char) data[i], (unsigned char) bufSourceData[i]);
		else
			pr_info("|%d | 0x%x | 0x%x | <--", i, (unsigned char) data[i], (unsigned char) bufSourceData[i]);
	
	pr_info("----------------------------------------\n");

	ret = copy_from_user(data, bufSourceData, bufCount);

	data[BUF_LEN-1] = '\0';

	if (!strcmp(data, euid) == 0)
		return -EINVAL;

	return ret;
}

const struct file_operations fops = {
	.write		= device_write,
	.read		= device_read
};

struct miscdevice miscdev = {
	.minor		= MISC_DYNAMIC_MINOR,
	.name		= device_name,
	.fops		= &fops
};

static int driver_entry(void)
{
	return misc_register(&miscdev);
}

static int driver_exit(void)
{
	misc_deregister(&miscdev);
}

module_init(driver_entry);
module_exit(driver_exit);
MODULE_LICENSE("GPL");
